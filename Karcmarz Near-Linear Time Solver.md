## Randomized Kaczmarz Method
$m \times n$ 행렬 $A$와 $m$차원 열벡터 $b$에 대해, $n$차원 벡터 $x$에 대한 방정식 $Ax = b$의 한 해를 $x^\star$라고 하자. **Randomized Kaczmarz method**는 아래 과정을 통해 이러한 $x^\star$를 구하는 알고리즘 중 하나이다.

$A$의 $i$번째 행을 $A_i$, $b$의 $i$번째 원소를 $b_i$라 하자. ($0 \le i < m$)
1. $x_0 = 0$
2. For $t$ in $0$...
	1. $A x_t = b$라면 알고리즘을 종료한다.
	2. 랜덤하게 $i$를 고른다. 이때 $i$가 뽑힐 확률이 ${\left|| A_i \right||}^2 = \left< A_i, A_i \right>$ 가 되도록 한다.
	3. $x_t$를 초평면 $\left< A_i, x \right> = b_i$에 사영시킨 벡터를 $x_{t+1}$로 지정한다.
### Randomized Kaczmarz Method의 수렴성
행렬 $A$의 [[Average Condition Number|average condition number]]를 $\tilde{\kappa}(A)$라고 할 때, $\tau = O\left( {\tilde{\kappa}}^2(A) \log{1/\varepsilon} \right)$번의 iteration 후에 정답과의 오차, 즉 의 값은 90% 이상의 확률로  이하로 떨어진다.
## Near-Linear Time Laplacian Solver
이 알고리즘은 상기한 randomized kaczmarz method를 조금 변형한 것이다.
### 가중치 없는 그래프 (모든 저항이 $1$)
- 표기법과 정의는 [[Graphs as Electrical Networks]] 참고.
- 스패닝 트리 $T$를 구성하는 알고리즘은 [[Low Stretch Spanning Tree]] 참고.

아래 알고리즘에서 추가로 사용되는 표기법은 아래와 같다.
- $G$의 한 사이클 $C$에 대해, 벡터 $1_C \in \left\{ -1, 0, 1 \right\}^m$은 $B 1_C = 0$을 만족하면서 $C$에 포함되지 않은 간선에 해당하는 모든 값은 $0$인 벡터이다. 그러면, 전기 회로의 특성상 $\left< 1_C, i \right> = 0$이다.
- 스패닝 트리 $T$에 속하지 않는 $G$의 간선 $e$에 대해  $C_e$는 $e$를 제외한 모든 간선이 $T$의 일부인 유일한 사이클이다.

Laplacian system을 푸는 것, 즉 $i$의 값을 알아내는 것은 아래 식을 만족하는 $f$를 찾는 것으로 충분하다.
$$ \forall e \notin T, \quad \left< 1_{C_e}, f \right> = 0 \quad \textrm{s.t. } Bf = e_s - e_t $$
1. $G$의 low stretch spanning tree $T$를 만든다. $0$번 정점을 $T$의 루트로 둔다.
2. $G$의 모든 간선에 방향을 준다. $T$에 속하는 간선에 대해선 리프로 뻗어나가는 방향을 주고, 그 외의 간선은 어떻게 주어도 상관 없다.
3. 이제부터 $f_0$부터 시작하여 값을 업데이트하며 정답을 찾을 것이다.
4. $T$에서의 LCA(*s*, *t*)를 *u*라고 하자. 그러면 $f_0$는 *s*와 *u* 사이 $T$에서의 경로에는 $-1$, *u*와 *t* 사이 $T$에서의 경로에는 $1$이라 두고, $T$에 속하지 않는 간선에 해당하는 값은 전부 $0$으로 둔다. 그러면 $Bf_0 = e_s - e_t$가 된다.
5. For $t$ in $0$...
	1. $T$에 속하지 않는 간선 $e$를 랜덤으로 하나 고른다. 이때, 랜덤으로 고르는 확률은 $|| 1_{C_e} || ^2 = |C|$에 비례하도록 한다.
	2. $f_t$를 초평면 $\left< 1_C, f \right> = 0$에 사영시킨 벡터를 $f_{t+1}$로 지정한다.
#### $f_t$ 의 관리
$f_t$를 $\left< 1_C, f \right> = 0$에 사영시킨 벡터는 아래와 같다.
$$ f_{t+1} = f_t - \frac{\left< f_t, 1_C \right>}{|| 1_C ||^2} 1_C $$
즉, $f_t$를 $f_{t+1}$로 업데이트하는 것은 $f_t$에서 특정 벡터를 빼는 것에 해당한다.

$f_t$의 각 원소를 $G$의 각 간선에 적힌 값으로써 관리해보자.  그러면 $f_t$를 $f_{t+1}$로 업데이트하기 위해선 $\left< f_t, 1_C \right>$를 빠르게 계산하여, 이것을 $f_t$의 각 값에 적절히 더하거나 빼는 것을 할 수 있어야 한다.

사이클 $C_e$는 간선 $e$, $e$의 끝점에서 $T를 통해 위로 올라가는 경로, 거기서부터 $e$의 시작점까지 $T$를 타고 아래로 내려가는 경로 세 부분으로 분리할 수 있다. 따라서 $\left< f_t, 1_C \right>$는 $T$에서 경로에서의 값의 합을 계산하면 구할 수 있다.
사이클의 분리를 고려했을 때, $f_t$를 $f_{t+1}$로 바꾸는 것은 비슷하게 경로에 특정 값을 더하거나 빼는 것에 해당한다. 이 모든 연산은 HLD로 구현이 가능하다.

따라서 $f$ 벡터는 HLD로 관리해야 빠르게 벡터를 업데이트할 수 있다.
### 가중치 있는 그래프
이 부분은 내가 스스로 생각해야 한다. 내 머리...

이때, 중요한 건 $1_C$의 정의를 잘 정하여 $f_t$의 관리를 HLD로 그대로 관리할 수 있어야 하고, 간선 $e$를 선택하는 확률분포를 적절히 선택하여 알고리즘이 빠르게 수렴할 수 있도록 해야 한다.